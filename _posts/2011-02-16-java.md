---
date: 2011-02-16
layout: post
title: !binary |
  amF2YeiHquWKqOijheeuseazqOaEj+eCuQ==
thread: 164
categories: 软件
tags:  java 注意
---

java入门书籍里面都会提到java比c++更加面向对象， *thinking in java* 开篇中提到的 __everything is an object__
其实java并不像ruby，pyhon之类的纯解释性的语言，java有char,byte,boolean,int,short,long,double,float8中基本类型
在需要对象时候可以将基本类型转化为对象，在jdk5的以前需要手动将int 转化为Integer

>       Integer i = new Integer(100)
>       Integer i = Integer.valueOf(100)


在jdk5之后出像autoboxing直接可以使用


>       Integer i = 100;//实际上还是在使用Integer i = Integer.valueOf(100)


使用起来较以前简洁，不过自动装箱有时候会出像奇怪的现象，如下：

__1.__
		Integer i1 = 100;
		Integer i2 = 100;

		if(i1==i2){
			System.out.println("i1 == i2");
		}


__2.__
		Integer i1 = 200;
		Integer i2 = 200;

		if(i1==i2){
			System.out.println("i1 == i2");
		}
		
		
两段代码尽然运行结果不一样～～至于为什么呢？
前面说过:此时自动装箱时会调用valueOf()方法，查看源代码如下

	public static Integer valueOf(int i) {
        assert IntegerCache.high >= 127;
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
	}

默认的IntegerCache.low 是-128，IntegerCache.high是127
上面原代码就可看出原因，结果不言自明～
